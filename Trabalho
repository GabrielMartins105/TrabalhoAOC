# Bitmap Medidas: 1,1,256,256, 1004xHeap (So funciona assim)


.data
#----------------------------------------------Vetores e afins-------------------------
    vetor: .space 40     # Vetor que fai armazenar as cores, coloquei so 3 para testar, depois tem que mudar
    			#P.S nao se esqueça que tem que multiplicar por 4 (por causa dos bytes) ex 12(tamanho) = 3(tamanho) x 4
    size:  .word 10       # Tamanho do vetor
    nivel: .word 1         # Nível atual
    dificuldade_set: .word 1 # 0 Normal 1 Dificil
#--------------------------------------------------------------------------

#------------------Coisas envolvendo o circulo-----------------------------------    
    cores:     .word   0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00  # Vermelho, Verde, Azul, Amarelo
    centroX:    .word   128      #Medidas do circulo
    centroY:    .word   128
    raio:     .word   100	#------------------
#---------------------------------------------------------------------------------------

#----------------Randomizador---------------------------------------------   
    min:    .word 1       # Valores para fazer o srand
    max:    .word 4     
 #---------------------------------------------------------
 
#-----------------Mensagens---------------------------------------------  
    cor_print: .asciiz "A cor selecionada e: "
    cor_resposta: .asciiz "Eu acho q a cor e: "
    print_erro: .asciiz "Voce errou"
    espaco: .asciiz " "
    gameover: .asciiz "Game Over" 
    print_acerto: .asciiz "Agora o proximo nivel "
    print_menu: .asciiz "Selecione uma opção: \n 1: Jogar \n 2: Modo dificil \n 3:Opçoes \n 4:Sair"
    modo_daltonico: .asciiz "Voce quer jogar o modo daltonico 1: Para sim ou 2: Para não?"
#-----------------------------------------------------



.text
main:

	# Seed para random
    	li $a0, 12345
    	li $v0, 30
    	syscall
    	
    	la $a0, print_menu     # Printf do menu
    	li $v0, 4		
   	syscall
   	
   	li $v0, 5  #Opçao menu
   	syscall
   	
   	move $t0,$v0 #selecionar
   	
   	bge $t0,4,final_saida #So para sair
   	#bge $t0,3,daltonismo #Funçao para colocar o modo daltonico(Incompleta)
   	j dificuldade # Altera a dificuldade
setting_dificuldade:
    
    li $t0, 0x10040000  # Endereço base do display
    
    # Inicializar coordenadas
    li $t1, 0           # y = 0
    li $t2, 256         # altura total
    
y_loop:
    li $t3, 0           # x = 0
    li $t4, 256         # largura total
    
x_loop:
    # Calcular distancia do centro
    sub $t5, $t3, 128   # x - centroX
    sub $t6, $t1, 128   # y - centroY
    
    # Verificar se está dentro do circulo (x² + y² < r²), usa a formula para confirmar se esta formando um circulo
    mul $t5, $t5, $t5   # (x - cx)²
    mul $t6, $t6, $t6   # (y - cy)²
    add $t7, $t5, $t6   # distancia ao quadrado
    
    lw $t8, raio
    mul $t8, $t8, $t8   # r²
    
    bge $t7, $t8, pula_pixel  # Pular se fora do círculo
    
    # Determinar quadrante
    blt $t3, 128, baixo_esq
    blt $t1, 128, topo_dir
    li $t9, 3           # Quadrante 3 (amarelo)
    j selecionar_cor
    
topo_dir:
    li $t9, 0           # Quadrante 0 (vermelho)
    j selecionar_cor
    
baixo_esq:
    blt $t1, 128, top_left
    li $t9, 2           # Quadrante 2 (azul)
    j selecionar_cor
    
top_left:
    li $t9, 1           # Quadrante 1 (verde)
    
selecionar_cor:
    # Calcular endereço do pixel
    sll $t5, $t1, 8     # y * 256
    add $t5, $t5, $t3   # + x
    sll $t5, $t5, 2     # * 4 (bytes por pixel)
    add $t5, $t5, $t0   # + endereço base
    
    # Carregar cor do quadrante
    sll $t6, $t9, 2     # índice * 4
    lw $t7, cores($t6) # carregar cor
    
    # Escrever pixel
    sw $t7, 0($t5)
    
pula_pixel:
    addi $t3, $t3, 1    # x++
    blt $t3, $t4, x_loop
    
    addi $t1, $t1, 1    # y++
    blt $t1, $t2, y_loop
    
    # Carregar o Vetor
    la $t0, vetor     # Carrega endereço base do vetor em $t0
    lw $t1, size      # Carrega tamanho do vetor em $t1
    li $t2, 0         # Inicializa contador (i = 0)
    
    # O jogo começa de fato
    
    
jal inicializar_vetor
    
jogo_loop:
	# Todas as funcoes/jumps
    jal mostrar_sequencia #Mostra o vetor das cores
    jal resposta # Acontece os inputs

    beqz $v0, game_over  # Se $v0 == 0 gameover :(

    jal proximo_nivel # Vai incrementando o vetor das cores
    j jogo_loop

game_over:
    la $a0, print_erro  # Mensagens de game over
    li $v0, 4
    syscall

    la $a0, gameover
    li $v0, 4
    syscall
final_saida:
    li $v0, 10
    syscall

inicializar_vetor:
    la $t0, vetor  #Pega o endereço do começo do vetor
    lw $t1, size  # E o tamanho 
    li $t2, 0 #Contador
geracao_cores:

    bge $t2, $t1, final_geracao # Vai preenchendo o vetor
    li $v0, 42
    li $a0, 0
    li $a1, 4
    syscall
    
    sw $a0, 0($t0)   #E vai salvando no vetor
    addi $t0, $t0, 4
    addi $t2, $t2, 1
    j geracao_cores
    
final_geracao:
    jr $ra

# Mostra a sequência atual
mostrar_sequencia:
    	la $a0, cor_print      # Printf para facilitar leitura
    	li $v0, 4		
   	 syscall		
    
    	la $t0, vetor     #Prepara o vetor das cores para mostrar no "mostrar_loop"
    	lw $t1, nivel
    	li $t2, 0
    
mostrar_loop:
    	bge $t2, $t1, fim_mostrar
    
    	# Mostra o numero/ cor quando conseguirmos implementar
    	lw $a0, 0($t0)
    	li $v0, 1
    	syscall
    
    	# Espaco para facilitar a leitura de numeros com cores acho q n vai precisar
   	 la $a0, espaco
   	 li $v0, 4
   	 syscall
    
    	addi $t0, $t0, 4 #Faz o loop
    	addi $t2, $t2, 1
    	j mostrar_loop
    
fim_mostrar:
    jr $ra

resposta:
    la $a0, cor_resposta   #Printf esperando o input do usuario
    li $v0, 4
    syscall
    
    la $t0, vetor     #Prepara o vetor das cores para ser comparado
    lw $t1, nivel
    li $t2, 0
    
resposta_loop:
    bge $t2, $t1, fim_resposta_ok
    
    # Lê número do usuário
    li $v0, 5	#Digita a cor( Depis tem que fazer com que seja o click do mouse)
    syscall
    move $t4,$v0  # Move a resposta para poder comparar
    
    # Verifica se esta correto
    lw $t3, 0($t0)
    bne $t4, $t3, resposta_errada  #Faz a comparacao
    
    addi $t0, $t0, 4   #Incrementa o vetor
    addi $t2, $t2, 1
    j resposta_loop
    
resposta_errada:
    li $v0, 0    # Retorna 0 (erro)
    jr $ra
    
fim_resposta_ok:
    li $v0, 1    # Retorna 1 tudo joia
    jr $ra

proximo_nivel:

    la $a0, print_acerto
    li $v0, 4
    syscall

    lw $t0, dificuldade_set   # Ve se esta no modo normal ou dificil
    beq $t0,1,proximo_nivel_hard # Se for no dificil vai para o loop hard
    
    lw $t0, nivel    # Vai aumentando o nivel junto com o vetor
    addi $t0, $t0, 1
    sw $t0, nivel
      
    la $t1, vetor 
    li $t2, 0

proximo_loop:
    beq $t2, $t0, gerar_nova_cor  # Acha onde colocar a nova cor
    addi $t1, $t1, 4
    addi $t2, $t2, 1
    j proximo_loop

gerar_nova_cor:
    li $v0, 42   # Gera uma nova cor aleatoria
    li $a0, 0
    li $a1, 4
    syscall
    sw $a0, 0($t1) #E salva no vetor

    jr $ra

dificuldade: 
	beq $t0,2, hard
	li $t1, 0
	sw $t1,dificuldade_set
	
	j setting_dificuldade
	
hard: 
	li $t1, 1
    	sw $t1, dificuldade_set       # seta dificuldade como 1 (difícil)

    	lw $t1, nivel    
    	addi $t1, $t1, 1              
    	sw $t1, nivel
	
	j setting_dificuldade
	
proximo_nivel_hard: #Exatamente a mesma coisa que o normal so que incrementa as cores de 2 em 2

    la $a0, print_acerto
    li $v0, 4
    syscall

    lw $t0, nivel    
    addi $t0, $t0, 2     # Incrementa o nível em 2
    sw $t0, nivel	

    la $t1, vetor        
    li $t2, 0

proximo_loop_hard:
    lw $t3, nivel
    sub $t3, $t3, 2         # Posição atual antes da adição
    beq $t2, $t3, gerar_duas_cores
    addi $t1, $t1, 4
    addi $t2, $t2, 1
    j proximo_loop_hard

# Gera duas cores novas
gerar_duas_cores:
    # Primeira nova cor
    li $v0, 42
    li $a0, 0
    li $a1, 4
    syscall
    sw $a0, 0($t1)

    addi $t1, $t1, 4

    # Segunda nova cor
    li $v0, 42
    li $a0, 0
    li $a1, 4
    syscall
    sw $a0, 0($t1)

    jr $ra
